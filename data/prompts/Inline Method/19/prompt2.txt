Inline method refactorings are frequently employed to eliminate unnecessary methods to improve readability. As a developer, imagine your team leader requests you to review a piece of code to identify potential inline method refactoring opportunities. The original code snippet is as follows:
```
package org.springframework.boot.web.server;

import org.springframework.boot.ssl.NoSuchSslBundleException;
import org.springframework.boot.ssl.SslBundle;
import org.springframework.boot.ssl.SslBundleKey;
import org.springframework.boot.ssl.SslBundles;
import org.springframework.boot.ssl.SslManagerBundle;
import org.springframework.boot.ssl.SslOptions;
import org.springframework.boot.ssl.SslStoreBundle;
import org.springframework.boot.ssl.jks.JksSslStoreBundle;
import org.springframework.boot.ssl.jks.JksSslStoreDetails;
import org.springframework.boot.ssl.pem.PemSslStoreBundle;
import org.springframework.boot.ssl.pem.PemSslStoreDetails;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

/**
 * {@link SslBundle} backed by {@link Ssl}.
 *
 * @author Scott Frederick
 * @author Phillip Webb
 * @since 3.1.0
 */
public final class WebServerSslBundle implements SslBundle {

    private final SslStoreBundle stores;

    private final SslBundleKey key;

    private final SslOptions options;

    private final String protocol;

    private final SslManagerBundle managers;

    private WebServerSslBundle(SslStoreBundle stores, String keyPassword, Ssl ssl) {
        this.stores = stores;
        this.key = SslBundleKey.of(keyPassword, ssl.getKeyAlias());
        this.protocol = ssl.getProtocol();
        this.options = SslOptions.of(ssl.getCiphers(), ssl.getEnabledProtocols());
        this.managers = SslManagerBundle.from(this.stores, this.key);
    }

    private static SslStoreBundle createPemStoreBundle(Ssl ssl) {
        PemSslStoreDetails keyStoreDetails = new PemSslStoreDetails(ssl.getKeyStoreType(), ssl.getCertificate(),
                ssl.getCertificatePrivateKey())
                .withAlias(ssl.getKeyAlias());
        PemSslStoreDetails trustStoreDetails = new PemSslStoreDetails(ssl.getTrustStoreType(),
                ssl.getTrustCertificate(), ssl.getTrustCertificatePrivateKey());
        return new PemSslStoreBundle(keyStoreDetails, trustStoreDetails);
    }

    private static SslStoreBundle createJksStoreBundle(Ssl ssl) {
        JksSslStoreDetails keyStoreDetails = new JksSslStoreDetails(ssl.getKeyStoreType(), ssl.getKeyStoreProvider(),
                ssl.getKeyStore(), ssl.getKeyStorePassword());
        JksSslStoreDetails trustStoreDetails = new JksSslStoreDetails(ssl.getTrustStoreType(),
                ssl.getTrustStoreProvider(), ssl.getTrustStore(), ssl.getTrustStorePassword());
        return new JksSslStoreBundle(keyStoreDetails, trustStoreDetails);
    }

    @Override
    public SslStoreBundle getStores() {
        return this.stores;
    }

    @Override
    public SslBundleKey getKey() {
        return this.key;
    }

    @Override
    public SslOptions getOptions() {
        return this.options;
    }

    @Override
    public String getProtocol() {
        return this.protocol;
    }

    @Override
    public SslManagerBundle getManagers() {
        return this.managers;
    }

    /**
     * Get the {@link SslBundle} that should be used for the given {@link Ssl} instance.
     * @param ssl the source ssl instance
     * @return a {@link SslBundle} instance
     * @throws NoSuchSslBundleException if a bundle lookup fails
     */
    public static SslBundle get(Ssl ssl) throws NoSuchSslBundleException {
        return get(ssl, null);
    }

    /**
     * Get the {@link SslBundle} that should be used for the given {@link Ssl} instance.
     * @param ssl the source ssl instance
     * @param sslBundles the bundles that should be used when {@link Ssl#getBundle()} is
     * set
     * @return a {@link SslBundle} instance
     * @throws NoSuchSslBundleException if a bundle lookup fails
     */
    public static SslBundle get(Ssl ssl, SslBundles sslBundles) throws NoSuchSslBundleException {
        return get(ssl, sslBundles, null);
    }

    @Deprecated(since = "3.1.0", forRemoval = true)
    @SuppressWarnings("removal")
    public static SslBundle get(Ssl ssl, SslBundles sslBundles, SslStoreProvider sslStoreProvider) {
        Assert.state(Ssl.isEnabled(ssl), "SSL is not enabled");
        String keyPassword = ssl.getKeyPassword();
        String bundleName = ssl.getBundle();
        if (StringUtils.hasText(bundleName)) {
            Assert.state(sslBundles != null,
                    () -> "SSL bundle '%s' was requested but no SslBundles instance was provided"
                            .formatted(bundleName));
            return sslBundles.getBundle(bundleName);
        }
        SslStoreBundle stores = createStoreBundle(ssl);
        return new WebServerSslBundle(stores, keyPassword, ssl);
    }

    private static SslStoreBundle createStoreBundle(Ssl ssl) {
        if (hasCertificateProperties(ssl)) {
            return createPemStoreBundle(ssl);
        }
        if (hasJavaKeyStoreProperties(ssl)) {
            return createJksStoreBundle(ssl);
        }
        throw new IllegalStateException("SSL is enabled but no trust material is configured");
    }

    static SslBundle createCertificateFileSslStoreProviderDelegate(Ssl ssl) {
        if (!hasCertificateProperties(ssl)) {
            return null;
        }
        SslStoreBundle stores = createPemStoreBundle(ssl);
        return new WebServerSslBundle(stores, ssl.getKeyPassword(), ssl);
    }

    private static boolean hasCertificateProperties(Ssl ssl) {
        return Ssl.isEnabled(ssl) && ssl.getCertificate() != null && ssl.getCertificatePrivateKey() != null;
    }

    private static boolean hasJavaKeyStoreProperties(Ssl ssl) {
        return Ssl.isEnabled(ssl) && ssl.getKeyStore() != null
                || (ssl.getKeyStoreType() != null && ssl.getKeyStoreType().equals("PKCS11"));
    }

}
```
If there are any refactoring opportunities, please do it and generate the refactored code. Otherwise, simply state that no refactoring is necessary.