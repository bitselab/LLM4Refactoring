Extract method refactorings are frequently employed to remove duplicate code snippets to improve readability and reusability.
##################################################
An extract method refactoring pattern is to extract repeated statements as a new method within the class. Here is an example of the extract method refactoring that follows this pattern.
The source code before refactoring is:
```
class ClientThread extends Thread
{
    public void run()
    {
        try
        {
            _db.init();
        }
        catch (DBException e)
        {
            e.printStackTrace();
            e.printStackTrace(System.out);
            return;
        }
        try
        {
            _workloadstate=_workload.initThread(_props,_threadid,_threadcount);
        }
        catch (WorkloadException e)
        {
            e.printStackTrace();
            e.printStackTrace(System.out);
            return;
        }
        //spread the thread operations out so they don't all hit the DB at the same time
        try
        {
            //GH issue 4 - throws exception if _target>1 because random.nextInt argument must be >0
            //and the sleep() doesn't make sense for granularities < 1 ms anyway
            if ( (_target>0) && (_target<=1.0) )
            {
                sleep(Utils.random().nextInt((int)(1.0/_target)));
            }
        }
        catch (InterruptedException e)
        {
            // do nothing.
        }

        try
        {
            if (_dotransactions)
            {
                long st=System.currentTimeMillis();
                while (((_opcount == 0) || (_opsdone < _opcount)) && !_workload.isStopRequested())
                {
                    if (!_workload.doTransaction(_db,_workloadstate))
                    {
                        break;
                    }

                    _opsdone++;

                    if (_target>0)
                    {
                        while (System.currentTimeMillis()-currTimeMillis<((double)_opsdone)/_target)
                        {
                            try
                            {
                                sleep(1);
                            }
                            catch (InterruptedException e)
                            {
                                // do nothing.
                            }

                        }
                    }
                }
            }
            else
            {
                long st=System.currentTimeMillis();
                while (((_opcount == 0) || (_opsdone < _opcount)) && !_workload.isStopRequested())
                {
                    if (!_workload.doInsert(_db,_workloadstate))
                    {
                        break;
                    }

                    _opsdone++;

                    if (_target>0)
                    {
                        while (System.currentTimeMillis()-currTimeMillis<((double)_opsdone)/_target)
                        {
                            try
                            {
                                sleep(1);
                            }
                            catch (InterruptedException e)
                            {
                                // do nothing.
                            }

                        }
                    }
                }
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
            e.printStackTrace(System.out);
            System.exit(0);
        }
        try
        {
            _db.cleanup();
        }
        catch (DBException e)
        {
            e.printStackTrace();
            e.printStackTrace(System.out);
            return;
        }
    }

}
```
The source code after refactoring is:
```
class ClientThread extends Thread
{
    public void run()
    {
        try
        {
            _db.init();
        }
        catch (DBException e)
        {
            e.printStackTrace();
            e.printStackTrace(System.out);
            return;
        }
        try
        {
            _workloadstate=_workload.initThread(_props,_threadid,_threadcount);
        }
        catch (WorkloadException e)
        {
            e.printStackTrace();
            e.printStackTrace(System.out);
            return;
        }
        //spread the thread operations out so they don't all hit the DB at the same time
        try
        {
            //GH issue 4 - throws exception if _target>1 because random.nextInt argument must be >0
            //and the sleep() doesn't make sense for granularities < 1 ms anyway
            if ( (_target>0) && (_target<=1.0) )
            {
                sleep(Utils.random().nextInt((int)(1.0/_target)));
            }
        }
        catch (InterruptedException e)
        {
            // do nothing.
        }

        try
        {
            if (_dotransactions)
            {
                long st=System.currentTimeMillis();
                while (((_opcount == 0) || (_opsdone < _opcount)) && !_workload.isStopRequested())
                {
                    if (!_workload.doTransaction(_db,_workloadstate))
                    {
                        break;
                    }

                    _opsdone++;

                    throttle(st);
                }
            }
            else
            {
                long st=System.currentTimeMillis();
                while (((_opcount == 0) || (_opsdone < _opcount)) && !_workload.isStopRequested())
                {
                    if (!_workload.doInsert(_db,_workloadstate))
                    {
                        break;
                    }

                    _opsdone++;

                    throttle(st);
                }
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
            e.printStackTrace(System.out);
            System.exit(0);
        }
        try
        {
            _db.cleanup();
        }
        catch (DBException e)
        {
            e.printStackTrace();
            e.printStackTrace(System.out);
            return;
        }
    }

    private void throttle(long currTimeMillis) {
        if (_target>0)
        {
            while (System.currentTimeMillis()-currTimeMillis<((double)_opsdone)/_target)
            {
                try
                {
                    sleep(1);
                }
                catch (InterruptedException e)
                {
                    // do nothing.
                }

            }
        }
    }
}
```
In this example, the developer extracted the following statements:
```
if (_target>0)
{
    while (System.currentTimeMillis()-currTimeMillis<((double)_opsdone)/_target)
    {
        try
        {
            sleep(1);
        }
        catch (InterruptedException e)
        {
            // do nothing.
        }

    }
}
```
as new method "throttle".
##################################################
As a developer, imagine your team leader requests you to review a piece of code to identify potential extract method refactoring opportunities that follows the refactoring pattern above. The original code snippet is as follows:
```
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

package org.elasticsearch.transport;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.elasticsearch.common.Strings;
import org.elasticsearch.common.settings.SecureString;
import org.elasticsearch.common.settings.Settings;
import org.elasticsearch.common.util.set.Sets;
import org.elasticsearch.core.Nullable;

import java.util.Collections;
import java.util.Map;
import java.util.Set;

import static org.elasticsearch.transport.RemoteClusterService.REMOTE_CLUSTER_CREDENTIALS;

public class RemoteClusterCredentialsManager {
    private static final Logger logger = LogManager.getLogger(RemoteClusterCredentialsManager.class);

    private volatile Map<String, SecureString> clusterCredentials = Collections.emptyMap();

    @SuppressWarnings("this-escape")
    public RemoteClusterCredentialsManager(Settings settings) {
        updateClusterCredentials(settings);
    }

    public final synchronized UpdateRemoteClusterCredentialsResult updateClusterCredentials(Settings settings) {
        final Map<String, SecureString> newClusterCredentials = REMOTE_CLUSTER_CREDENTIALS.getAsMap(settings);
        if (clusterCredentials.isEmpty()) {
            clusterCredentials = newClusterCredentials;
            logger.debug(
                    () -> Strings.format(
                            "Updated remote cluster credentials for clusters: [%s]",
                            Strings.collectionToCommaDelimitedString(clusterCredentials.keySet())
                    )
            );
            return new UpdateRemoteClusterCredentialsResult(Set.copyOf(newClusterCredentials.keySet()), Collections.emptySet());
        }

        final Set<String> addedClusterAliases = Sets.difference(newClusterCredentials.keySet(), clusterCredentials.keySet());
        final Set<String> removedClusterAliases = Sets.difference(clusterCredentials.keySet(), newClusterCredentials.keySet());
        clusterCredentials = newClusterCredentials;
        logger.debug(
                () -> Strings.format(
                        "Updated remote cluster credentials for clusters: [%s]",
                        Strings.collectionToCommaDelimitedString(clusterCredentials.keySet())
                )
        );
        assert Sets.haveEmptyIntersection(removedClusterAliases, addedClusterAliases);
        return new UpdateRemoteClusterCredentialsResult(addedClusterAliases, removedClusterAliases);
    }

    public record UpdateRemoteClusterCredentialsResult(Set<String> addedClusterAliases, Set<String> removedClusterAliases) {}

    @Nullable
    public SecureString resolveCredentials(String clusterAlias) {
        return clusterCredentials.get(clusterAlias);
    }

    public boolean hasCredentials(String clusterAlias) {
        return clusterCredentials.containsKey(clusterAlias);
    }

    public static final RemoteClusterCredentialsManager EMPTY = new RemoteClusterCredentialsManager(Settings.EMPTY);
}
```
If there are any refactoring opportunities, please do it and generate the refactored code. Otherwise, simply state that no refactoring is necessary.